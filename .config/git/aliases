# vim: set filetype=gitconfig : ~
# vim: set shiftwidth=4 : ~
# vim: set softtabstop=0 : ~
# vim: set noexpandtab : ~

# for debug use next
# cb = ! set -x && ...

[alias]

	# ============= [ ADD ] =============
    # ABBR: [AD]d
    # DESC: just an alias to `git add`
	ad = add
    # ABBR: [A]dd [F]orcibly
    # DESC: `git add` with a `--force` option
	af = add --force
    # ABBR: [A]dd [P]atch
    # DESC: patch-based interactive version of 'git add'
	ap = add -p
    # ABBR: [A]dd [H]ere
    # DESC: add all stuff starting from current directory
	ah = add .



	# ============= [ BLAME_____________________ ] =============
    # ABBR: [BL]ame
    # DESC: a bit tuned version of git blame command
	# http://goo.gl/4yyu5v
	bl = blame HEAD



	# ============= [ BRANCH____________________ ] =============
    # ABBR: [B]branch [A]ll
    # DESC: show all branches
	ba = branch -a
	# show amount of commits in branch
	bc = "!f() { git rev-list --count HEAD ^${1-`git bp`}; }; f"
	bd = branch -D
	bm = "!f() { test -z $1 && git branch --move \"$(git bn | vipe)\" || \
        git branch --move \"$@\"; \
        echo \"Branch has been renamed to '$(git bn)'\"; }; f"
	# show name of the active branch
	bn = rev-parse --abbrev-ref HEAD
	# get parent branch of the current branch (still not reliable)
	# http://stackoverflow.com/questions/3161204/
	# https://gist.github.com/joechrysler/6073741
	bp = ! git show-branch \
		| sed "s/].*//" \
		| grep "\\*" \
		| grep -v "$(git rev-parse --abbrev-ref HEAD)" \
		| head -n1 \
		| sed "s/^.*\\\\[//";
	br = branch
	bt = branch -r
	bu = branch --unset-upstream
	bv = branch -vv
	# ABBR: [B]ranch [Z]ero
	# DESC: ...
	bz = !git symbolic-ref refs/remotes/origin/HEAD --short | sed 's|.*/||'



	# ============= [ CHECKOUT__________________ ] =============
	cb = ! create-branch-name
	cd = "!f() { git checkout `git config user.branch`; }; f"
    # https://le0nidas.gr/2020/03/27/git-alias-with-parameters/
	# co = "!f() { git checkout $(git branch | grep $1); }; f"
	co = checkout
	# ABBR: [C]heckout p[R]evious
	# DESC: a quick way to checkout a branch that was active before current one
	cr = checkout -
	ct = ! git checkout -b "tmp_branch$(expr $(git br -l 'tmp_branch*' | wc -l | tr -d \"[:blank:]\") + 1)"



	# ============= [ CHERRY-PICK_______________ ] =============
	# ABBR: [C]herry [P]ick
	# DESC: just an alias to `cherry-pick`
	cp = cherry-pick



	# ============= [ CLONE_____________________ ] =============
	cl = clone
    c1 = clone --depth=1



	# ============= [ COMMIT____________________ ] =============
	ca = commit --all --message WIP
	ce = commit --allow-empty
	cf = commit --all --amend -c HEAD
	ch = commit -m WIP
	ci = commit
	cm = commit --amend
	cn = commit --amend --no-edit --date=now
	cq = "!f() { git add ./$GIT_PREFIX/$1 && git commit --only ./$GIT_PREFIX/$1 -m \"WIP: $1\"; }; f"
	cs = commit --all --amend -C HEAD
	cu = commit --amend --no-edit --reset-author



	# ============= [ CONFIG____________________ ] =============
	ec = config --global -e
	ae = "!f() { $(git var GIT_EDITOR) ~/.config/git/aliases ; }; f"
	ag = "!f() { git config -l | grep alias | cut -c 7- | grep \"^$1=\" ; }; f"
	al = !git config -l | grep alias | cut -c 7-




	# ============= [ DIFF______________________ ] =============
	# checks if there are any changes;
	d1 = diff HEAD^
	da = "!f() { test -n \"$(git ls-files -m)\"; }; f"
	dc = diff --cached
	di = diff
	dn = "!f() { git da && p= || p=\"HEAD~${1-`git bc`}\" ; git diff --numstat $p ; }; f"
	dq = "!f() { git da && p= || p=\"HEAD~${1-`git bc`}\" ; git diff --shortstat $p ; }; f"
	ds = "!f() { git da && p= || p=\"HEAD~${1-`git bc`}\" ; git diff --stat --find-copies $p ; }; f"
	dt = difftool
	t1 = d1 --stat



	# ============= [ INIT______________________ ] =============
	it = "!f() { git init && git commit -m \"empty root\" --allow-empty; }; f"



	# ============= [ LOG_______________________ ] =============
	# ABBR: [L]og [\d]
	# DESC: show log of X most recent items excluding merge commits
	l1 = log -n 1 --no-merges
	l2 = log -n 2 --no-merges
	l3 = log -n 3 --no-merges
	# 'b' letter but 'log' command; shows log in current branch only
	bo = "!f() { git log --no-merges ${1-`git bp`}..; }; f"

	lf = "!f() { git l1 --decorate --stat; }; f"
	lg = log -p
	ln = log --name-only
	ls = log --pretty=format:"%C(yellow)%h\\ %Cgreen%ad%Cred%d\\ %Creset%s\\ %Cblue[%aN]" --decorate --date=short
	lv = "!f() { git log --decorate --stat -${1}; }; f"
	#hist = log --pretty=format:\"%h %ad | %s%d [%an]\" --graph --date=short
	#lol = log --graph --decorate --pretty=oneline --abbrev-commit
	#lola = log --graph --decorate --pretty=oneline --abbrev-commit --all



	# ============= [ MERGE] =============
	# ABBR: [M]erge [M]ain
	# DESC: an alias to merge mainline branch into current one
	mm = !git merge $(git bz)



	# ============= [ MERGETOOL__________________] =============
	mt = mergetool



	# ============= [ PULL______________________ ] =============
	pl = pull --ff-only



	# ============= [ PUSH______________________ ] =============
	# TODO replace `origin` with dynamic param
	pd = "!f() { git push origin --delete $1; }; f"
	pf = push --force
	ph = push
	px = push --no-verify



	# ============= [ REBASE____________________ ] =============
	ra = rebase --abort
	# if passed string is a number - do rebase by commits number
	# TODO need to make sure passed number is not a commit hash
	rb = "!f() { git rev-parse -q --verify $1 \
		&& git rebase $1 \
		|| git rebase -i HEAD~$1; }; f"
	rc = rebase --continue
	rk = rebase --skip
	rd = "!f() { git rebase `git config user.branch` ; }; f"



	# ============= [ REMOTE____________________ ] =============
	# mp = remote prune origin



	# ============= [ REMOVE ] =============
	rk = rm --cached



	# ============= [ RESET_____________________ ] =============
	rh = "!f() { git reset --hard HEAD~${1-1}; }; f"
	rs = "!f() { git reset --soft HEAD~${1-1}; }; f"
	rt = "!f() { test -z $1 && git reset HEAD || git reset HEAD $1; }; f"



	# ============= [ restore ] =============
    # ABBR: [R]estore sta[G]ed
    # DESC: drop file(s) from staging area
	rg = restore --staged



	# ============= [ STASH_____________________ ] =============
	sh = stash
	sl = stash list
	sp = stash pop
	ss = stash show -p
	si = stash -p
	sd = "!f() { git stash drop stash@{$1}; }; f"



	# ============= [ STATUS ] =============
	sa = status --untracked-files=no
    # ABBR: [S]tatus [C]onflict
    # DESC: an alias to list files in 'confilicted' state
    # https://stackoverflow.com/a/10874862/1344249
    sc = diff --name-only --diff-filter=U
    sg = status --ignored .
	st = status --short --branch
	su = ls-files --other | grep -v ./
	sv = status



	# ============= [ TAG_______________________ ] =============
	tr = tag -l
	tl = git describe --tags --abbrev=0
	td = "!f() { git tag -d $1; }; f"
	tv = show-ref --tags --abbrev
	tr = ls-remote --tags origin
	tw = "!f() { git tag -d $1 && git push origin :refs/tags/$1; }; f"



	# ============= [ SUBMODULE_________________ ] =============
	mu = submodule update --recursive
	mi = submodule update --init --recursive



	# ============= [ __________________________ ] =============
	os = shortlog --summary --numbered
	#ls = ls-files

	# git grep through all history
	gr = "!f() { git rev-list --all | xargs git grep -F \"$1\"; }; f"

	fup = log --since '1 day ago' --oneline "--author=$(git config --get user.email)"
	#freq = !history | grep git | cut -c 8- | sort | uniq -c | sort -n -r | head -n 5

	as = !git ls-files | xargs -n1 git blame --line-porcelain | sed -n 's/^author //p' | sort -f | uniq -ic | sort -nr
    or = [ ! -z `git rev-parse --show-cdup` ] && cd `git rev-parse --show-cdup || pwd`
    #gh = "!f() { cd \"$(git rev-parse --show-toplevel)\"; }; f"



    # ============= [ COMMIT QUEUE ] =============
    # ABBR: [Q]ueue [D]efine [D]ay
    # DESC: Prints special token that makes queue system skip one day
    qdd = "! git config user.queueSkipDay"

    # ABBR: [Q]ueue [D]efine [Y]ear
    # DESC: Prints special token that makes queue system skip all further days
    qdy = "! git config user.queueSkipForever"

    # ABBR: [Q]ueue [A]ppend
    # DESC: Appends passed string to the end of queue file
    qa = "!f() { echo \"$1\" >> `git qf`; }; f"

    # ABBR: [Q]ueue [C]urrent
    # DESC: Appends currently active branch to the queue
    qc = "!f() { git qa `git bn`; }; f"

    # ABBR: [Q]ueue [D]ay
    # DESC: Appends special token (that skips 1 day) to the queue
    qd = "!f() { git qp `git qdd` ; }; f"

    # ABBR: [Q]ueue [E]dit
    # DESC: Opens queue file in editor used by git commands
    qe = "!f() { $(git var GIT_EDITOR) `git qf`; }; f"

    # ABBR: [Q]ueue [F]ile
    # DESC: Prints relative (to the repo root) path to queue file
    qf = !FP="$(git rev-parse --git-dir)/automerge-queue" && test -e "$FP" || touch "$FP" && echo "$FP"

    # ABBR: [Q]ueue [L]ist
    # DESC: Prints content of queue file
    ql = "!f() { cat `git qf`; }; f"

    # ABBR: [Q]ueue [P]repend
    # DESC: Prepends passed string to the start of queue file
    qp = "!f() { echo \"$1\n$(cat `git qf`)\" > `git qf` ; }; f"

    # ABBR: [Q]ueue [N]ow
    # DESC: Prepends current branch to the start of queue file
    #       and immediately processes it
    qn = "! git q0 && git qt"

    # ABBR: [Q]ueue [R]egister
    # DESC: Registers current repo as one that has Q file
    qr = !RD=$(git rev-parse --show-toplevel) && \
            mkdir -p $HOME/.local/share/git && \
            touch $HOME/.local/share/git/queue-repos && \
            echo $RD >> $HOME/.local/share/git/queue-repos

    # ABBR: [Q]ueue [T]op
    # DESC: Processes first item from queue file
    qt = "! land-branch ."

    # ABBR: [Q]ueue [Y]ear
    # DESC: Appends special token that makes commit system skip any actions forever
    qy = "!f() { git qp `git qdy` ; }; f"

    # ABBR: [Q]ueue [0]
    # DESC: Prepends current branch to the start of queue file
    q0 = "!f() { git qp `git bn`; }; f"

    # ABBR: [Q]ueue [1]
    # DESC: Prints first item from queue file
    q1 = "!f() { head -n 1 `git qf`; }; f"

